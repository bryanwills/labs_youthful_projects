baud
_!@@!_
0.1
_!@@!_
double getInterpolatedValue(double[] sampleData, double sampleIndex)
{
	if (sampleIndex > sampleData.Length - 1) sampleIndex = sampleData.Length - 1;
	else if (sampleIndex < 0 + 1) sampleIndex = 0;

	double proportion = sampleIndex - Math.Truncate(sampleIndex);
	double v1 = sampleData[(int)Math.Truncate(sampleIndex)];
	double v2 = sampleData[(int)Math.Ceiling(sampleIndex)];
	return v2 * proportion + v1 * (1 - proportion);
}

//$$Main

//load from doubles
string allfile;
using (System.IO.TextReader tr = new System.IO.StreamReader(@"C:\pydev\mainsvn\audio\Experiments\doublependulum\tx.csv"))
     allfile = tr.ReadToEnd();
string[] sparts = allfile.Replace("\r\n","\n").Split('\n');
allfile=null;

WaveAudio pseudoAudio = new WaveAudio(1);
pseudoAudio.LengthInSamples= sparts.Length; 
int j=0;
foreach(string part in sparts)
{
	if (part.Trim()=="") continue;
	string[] sparts2= part.Split(',');
	double x1=double.Parse(sparts2[0]);
	double y1=double.Parse(sparts2[1]);
	double x2=double.Parse(sparts2[2]);
	double y2=double.Parse(sparts2[3]);
	
	// directly set the audio to this? that'd be weird???
	// we can use this as a pseudo-file, in order to get interpolation
	// I wonder what'd it sound like???
	
	pseudoAudio.data[0][j] = y1;
	j++;
}

result=pseudoAudio;

// now do some more things with the audio.
WaveAudio wout = new WaveAudio(1);
wout.LengthInSeconds=10.1;
// make this the longer one, where we interpolate.
double freq = 140.0;
int nperiod=(int)(wout.getSampleRate()/freq);
int nPieces = (int)((10*wout.getSampleRate())/((double)nperiod));
double smoothness=1.1;
j=0;
double peak=smoothness;
FN1 quadup=delegate(double x) {return peak*x*x- peak;};
FN1 quaddn=delegate(double x) {return peak - peak*x*x;};
int c=0;
double[] ar = wout.data[0];//ref.
for(int i=0; i<9.999*wout.getSampleRate(); i+=nperiod)
{
	double fpos=i/((double)10*wout.getSampleRate());
	/*if (fpos>0){
	System.Windows.Forms.MessageBox.Show(""+fpos);
	System.Windows.Forms.MessageBox.Show(""+nperiod);
	return null;}*/
	double otherCoord = pseudoAudio.LengthInSamples*fpos;
	double val = getInterpolatedValue(pseudoAudio.data[0],otherCoord);
	
	double pwidth=val;
	int quartersection = (int)((nperiod - nperiod * Math.Abs(pwidth)) / 4.0);
	int flatsection = nperiod - (quartersection*4);

	if (pwidth>0) {
	c=fillar(ar,c,c+quartersection,quaddn,-1,0); //bending up
	c=fillar(ar,c,c+flatsection,peak); //flat
	c=fillar(ar,c,c+quartersection,quaddn,0,1); //bending down
	c=fillar(ar,c,c+quartersection*2,quadup,-1,1); //happy face
	} else {
	c=fillar(ar,c,c+quartersection*2,quaddn,-1,1); //sad face
	c=fillar(ar,c,c+quartersection,quadup,-1,0); //bending down
	c=fillar(ar,c,c+flatsection,-peak); //flat
	c=fillar(ar,c,c+quartersection,quadup,0,1); //bending up
	}
}
//fix ar.
for (int i=0; i<ar.Length;i++) if (ar[i]>1.0) ar[i]=1.0; 
else if (ar[i]<-1.0) ar[i]=-1.0;

result=wout;
//$$EndMain

static int fillar(double[] ar, int current, int end, double constant)
{
	for(int i=current; i<=end; i++) ar[i]=constant;
	return end;
}
static int fillar(double[] ar, int current, int end, FN1 fn, double x1, double x2)
{
	double scale = (x2-x1)/((double)1+end-current);
	for(int i=current; i<=end; i++) ar[i]=fn(scale*(i-current)+x1);
	return end+1;
}

class NQuadratic : CsWaveAudio.SynthBases.PeriodicSynthesisBase
{
	double[] ar;
	//example of basic sine
	public NQuadratic(double freq, double amplitude, double pwidth, double smoothness) : base(freq, amplitude) {
		int nperiod=(int) period;
		ar=new double[(nperiod+4)]; 
		
		double peak=smoothness;
		int quartersection = (int)((nperiod - nperiod * Math.Abs(pwidth)) / 4.0);
		int flatsection = nperiod - (quartersection*4);
		FN1 quadup=delegate(double x) {return peak*x*x- peak;};
		FN1 quaddn=delegate(double x) {return peak - peak*x*x;};
		
		int c=0;
		if (pwidth>0) {
		c=fillar(ar,c,c+quartersection,quaddn,-1,0); //bending up
		c=fillar(ar,c,c+flatsection,peak); //flat
		c=fillar(ar,c,c+quartersection,quaddn,0,1); //bending down
		c=fillar(ar,c,c+quartersection*2,quadup,-1,1); //happy face
		} else {
		c=fillar(ar,c,c+quartersection*2,quaddn,-1,1); //sad face
		c=fillar(ar,c,c+quartersection,quadup,-1,0); //bending down
		c=fillar(ar,c,c+flatsection,-peak); //flat
		c=fillar(ar,c,c+quartersection,quadup,0,1); //bending up
		}
		//trunc to -1/1
		for (int i=0; i<ar.Length;i++) if (ar[i]>1.0) ar[i]=1.0; 
			else if (ar[i]<-1.0) ar[i]=-1.0;
	}
	protected override double WaveformFunction(int i)
	{
		if (i>=period) throw new Exception("Beyond range");
		return ar[i];
	}
}

_!@@!_
1
_!@@!_
0
_!@@!_
0.0001
_!@@!_
0
_!@@!_
0
_!@@!_
