baud
_!@@!_
0.1
_!@@!_
public class RedNoiseSmoothed : CsWaveAudio.SynthBases.SynthesisBase
{
	protected readonly double freq;
	protected readonly double amplitude;
	protected readonly int chunksbeforeswitch;
	protected readonly double rednoisefactor;
	protected readonly double smoothing; //from 0.0 to 1.0

	public RedNoiseSmoothed(double freq, double amplitude) : this(freq, amplitude, 5, 0.2, 0.91) { }
	public RedNoiseSmoothed(double freq, double amplitude, int chunksbeforeswitch, double rednoisefactor, double smoothing)
	{
		this.rednoisefactor = rednoisefactor;
		this.chunksbeforeswitch = chunksbeforeswitch;
		this.freq = freq;
		this.amplitude = amplitude;
		this.smoothing = smoothing;
	}
	protected override double[] generate(int nSamples)
	{
		double[] outData = new double[nSamples];
		Random rand = new Random(12); //if a new random is created every time, it doesn't update fast enough!

		int freqInSamples = (int)((1 / freq) * SampleRate);
		int numChunks = nSamples / freqInSamples;
		WaveAudio chunk = null;
		for (int i = 0; i < numChunks; i++)
		{
			if (i % this.chunksbeforeswitch == 0)
			{
				if (chunk == null)
				{
					//seed with Sine wave
					chunk = new Sine(210, amplitude / 4).CreateWaveAudio(1 / freq + 0.01);
				}
				else
				{
					WaveAudio newchunk = new RedNoise(amplitude, rednoisefactor, rand).CreateWaveAudio(1 / freq + 0.01);
					chunk = WaveAudio.Mix(chunk, this.smoothing, newchunk, 1 - this.smoothing);
				}
			}
			Array.Copy(chunk.data[0], 0, outData, i * freqInSamples, freqInSamples);
		}
		//fill in the rest
		if (numChunks * freqInSamples < nSamples)
			Array.Copy(chunk.data[0], 0, outData, numChunks * freqInSamples, nSamples - numChunks * freqInSamples);

		return outData;
	}
}
	

//$$Main
WaveAudio j1 = new RedNoiseSmoothed(100, 0.1).CreateWaveAudio(19.5);
result = j1;

//$$EndMain


_!@@!_
1
_!@@!_
0
_!@@!_
0
_!@@!_
0
_!@@!_
0
_!@@!_
