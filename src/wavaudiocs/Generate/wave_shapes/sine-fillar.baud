baud
_!@@!_
0.1
_!@@!_

static void fillar(double[] ar, ref int i, ref double curpos, double start, double end, double inc, double constant)
{
	while(curpos>=start && curpos<end)
	{
		ar[i] = constant;
		i++;
		curpos += inc; if (curpos>1.0) curpos-=1.0;
	}
}
static void fillar(double[] ar, ref int i, ref double curpos, double start, double end, double inc, FN1 fn, double x1, double x2)
{
	//0 should map to f(0)
	//n-1 should map to f(n-1)
	double scale = (x2-x1)/(end-start);
	
	while(curpos>=start && curpos<end)
	{
		ar[i] = fn(scale*(curpos-start)+x1);
		i++;
		curpos += inc; if (curpos>1.0) curpos-=1.0;
	}
}

class NSine : CsWaveAudio.SynthBases.HighPeriodicSynthesisBase
{
	//example of basic sine
	public NSine(double freq, double amplitude) : base(freq, amplitude) {
		
		
		
		//ah, perhaps because nperiod/4 is not an integer? that's probably it...
		
	}
	protected override void WaveformFunction(double [] ar)
	{
//void fillar(double[] ar, ref int i, ref double curpos, double start, double end, double inc, FN1 fn, double x1, double x2)
		int i=0;
		double curpos=0.0;
		double inc = this.timeScaleOne;
		while (i<ar.Length-400)
		{
			fillar(ar,ref i,ref curpos, 0.0, 0.25, inc,Math.Sin,0,Math.PI/2);
			fillar(ar,ref i,ref curpos, 0.25, 0.5, inc,Math.Sin,Math.PI/2,Math.PI);
			fillar(ar,ref i,ref curpos, 0.5, 0.75, inc,Math.Sin,Math.PI,Math.PI*1.5);
			fillar(ar,ref i,ref curpos, 0.75, 1.0, inc,Math.Sin,Math.PI*1.5,Math.PI*2);
		}
	}
}
 
//$$Main
WaveAudio input = new NSine(240,.75).CreateWaveAudio(1.0);
result=input;
//$$EndMain


_!@@!_
1
_!@@!_
0
_!@@!_
0
_!@@!_
0
_!@@!_
0
_!@@!_
